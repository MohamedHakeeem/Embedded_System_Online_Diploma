/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include "STM32F103X6.h"
#include "stm32f103x6_gpio_driver.h"
#include "stm32f103x6_usart_driver.h"
#include "stm32f103x6_spi_driver.h"
#include "lcd.h"
#include "Keypad.h"


//#define MCU_Act_As_Master
//#define MCU_Act_As_Slave

/* ========= Global variables ========== */
uint16_t data;


void USART1_CallBack(void)
{
#ifdef MCU_Act_As_Master
	MCAL_UART_ReceiveData(USART1,  &data, disable);
	MCAL_UART_SendData(USART1,  &data, enable);

	/* ========= Send Data To SPI1 =========== */

	/* Slave Selection (Low), to listen  */
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, 0);

	/* Send & Receive data */
	MCAL_SPI_TX_RX(SPI1, &data, SPIenable);

	/* Slave Selection (High) idle mode */
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, 1);
#endif
}




void SPI1_CallBack(IRQ_SOURCE IRQ_src)
{
#ifdef MCU_Act_As_Slave
	/* If RX Buffer Not Empty Interrupt */
	if(IRQ_src.RXNE)
	{
		/* Receive data */
		MCAL_SPI_ReceiveData(SPI1, &data, SPIenable);

		/* Send the Received data to the terminal to see it */
		MCAL_UART_SendData(USART1,  &data, enable);
	}
#endif
}



int main(void)
{



	/* Configuration of USART1 */
	UART_Config Uart_config;

	Uart_config.BaudRate = UART_BaudRate_9600;
	Uart_config.HwFlowCtl = UART_HwFlowCtl_NONE;
	Uart_config.IRQ_Enable = UART_IRQ_Enable_RXNEIE;
	Uart_config.P_IRQ_CallBack = USART1_CallBack;
	Uart_config.Parity = UART_Parity__NONE;
	Uart_config.Payload_Length = UART_Payload_Length_8B;
	Uart_config.StopBits = UART_StopBits__1;
	Uart_config.USART_Mode = UART_MODE_TX_RX;

	MCAL_UART_Init(USART1, &Uart_config);
	MCAL_UART_GPIO_Set_Pins(USART1);

	/* Configuration of SPI1 */
	SPI_Config_t SPI1_Config;

	/* Common Configuration */
	SPI1_Config.BaudRate_Prescaler = SPI_BAUDRATEPRESCALER_8;
	SPI1_Config.CLKPhase = SPI_CLKPHASE_SECONDEDGE;
	SPI1_Config.CLKPolarity = SPI_CLKPOLARITY_HIGH_IDLE;
	SPI1_Config.Data_Order = SPI_MSB_TRANSMITTED_FIRST;
	SPI1_Config.Data_Size = SPI_8BIT_DATASIZE;
	SPI1_Config.Communication_Mode = SPI_DIRECTION_2LINES;

#ifdef MCU_Act_As_Master
	SPI1_Config.SPI_Mode = SPI_MASTER_MODE;
	SPI1_Config.IRQ_Enable = SPI_IRQ_Disable;
	SPI1_Config.IRQ_CallBack = NULL;
	SPI1_Config.NSS = SPI_NSS_Soft_NSSInternalSoft_Set;	/* To Control when open & when close, Set as Active High */

	/* Configuration of SS */
	GPIO_PinConfig_t SS_Config;

	/* Configure SS at PA4 by GPIO */
	SS_Config.GPIO_PinNumber = GPIO_PIN_4;
	SS_Config.GPIO_Mode = GPIO_Mode_Out_push_pull;
	SS_Config.GPIO_Speed = GPIO_Speed_10MHz;

	MCAL_GPIO_Init(GPIOA, &SS_Config);

	/* Force the slave select (High) idle mode */
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, 1);
#endif

#ifdef MCU_Act_As_Slave
	SPI1_Config.SPI_Mode = SPI_SLAVE_MODE;
	SPI1_Config.IRQ_Enable = SPI_IRQ_Enable_RXNEIE;
	SPI1_Config.NSS = SPI_NSS_Hard_Slave;
	SPI1_Config.IRQ_CallBack = SPI1_CallBack;
#endif

	MCAL_SPI_Init(SPI1, &SPI1_Config);
	MCAL_SPI_GPIO_Set_Pins(SPI1);

	/* Loop For Ever */
	while(1){}
	return 0;
}


